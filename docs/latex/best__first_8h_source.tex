\doxysection{best\+\_\+first.\+h}
\hypertarget{best__first_8h_source}{}\label{best__first_8h_source}\index{/Users/spirosmag/Documents/AlgoPlus/src/machine\_learning/search\_algorithms/best\_first/best\_first.h@{/Users/spirosmag/Documents/AlgoPlus/src/machine\_learning/search\_algorithms/best\_first/best\_first.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{preprocessor}{\#pragma\ once}}
\DoxyCodeLine{00002\ \textcolor{preprocessor}{\#ifndef\ BEST\_FIRST\_H\ }}
\DoxyCodeLine{00003\ \textcolor{preprocessor}{\#define\ BEST\_FIRST\_H\ }}
\DoxyCodeLine{00004\ }
\DoxyCodeLine{00005\ \textcolor{preprocessor}{\#ifdef\ \_\_cplusplus}}
\DoxyCodeLine{00006\ \textcolor{preprocessor}{\#include\ <iostream>}}
\DoxyCodeLine{00007\ \textcolor{preprocessor}{\#include\ <unordered\_map>}}
\DoxyCodeLine{00008\ \textcolor{preprocessor}{\#include\ <queue>}}
\DoxyCodeLine{00009\ \textcolor{preprocessor}{\#include\ <climits>}}
\DoxyCodeLine{00010\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00011\ }
\DoxyCodeLine{00015\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{class\ }\mbox{\hyperlink{classbest__first}{best\_first}}\{}
\DoxyCodeLine{00016\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00017\ \ \ std::unordered\_map<T,\ std::vector<std::pair<T,\ double>\ >\ >\ adj;\ }
\DoxyCodeLine{00018\ \ \ std::unordered\_map<T,\ double>\ nodes;}
\DoxyCodeLine{00019\ \ \ }
\DoxyCodeLine{00020\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00021\ }
\DoxyCodeLine{00028\ \ \ \textcolor{keyword}{explicit}\ \mbox{\hyperlink{classbest__first_a023c0fe7138ff505951941ac43826293}{best\_first}}(std::unordered\_map<T,\ std::vector<std::pair<T,\ double>\ >\ >\ v\ =\ \{\},}
\DoxyCodeLine{00029\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::unordered\_map<T,\ double>\ nodes\ =\ \{\})\{}
\DoxyCodeLine{00030\ \ \ \ \ \textcolor{keywordflow}{try}\{}
\DoxyCodeLine{00031\ \ \ \ \ \ \ \textcolor{keywordflow}{if}((!v.empty()\ \&\&\ nodes.empty())\ ||\ (v.empty()\ \&\&\ !nodes.empty()))\{}
\DoxyCodeLine{00032\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{throw}\ std::logic\_error(\textcolor{stringliteral}{"{}You\ have\ to\ provide\ two\ non-\/empty\ maps"{}});}
\DoxyCodeLine{00033\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00034\ \ \ \ \ \ \ \textcolor{keywordflow}{if}(!v.empty()\ \&\&\ !nodes.empty())\{}
\DoxyCodeLine{00035\ \ \ \ \ \ \ \ \ this-\/>adj\ =\ v;}
\DoxyCodeLine{00036\ \ \ \ \ \ \ \ \ this-\/>nodes\ =\ nodes;}
\DoxyCodeLine{00037\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00038\ \ \ \ \ \}}
\DoxyCodeLine{00039\ \ \ \ \ \textcolor{keywordflow}{catch}(std::logic\_error\ \&e)\{}
\DoxyCodeLine{00040\ \ \ \ \ \ \ std::cerr\ <<\ e.what()\ <<\ \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{00041\ \ \ \ \ \}}
\DoxyCodeLine{00042\ \ \ \}}
\DoxyCodeLine{00043\ \ \ }
\DoxyCodeLine{00049\ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classbest__first_ac6a039d4c6f83eb9707c774a325a0573}{insert\_node}}(T\ u,\ \textcolor{keywordtype}{double}\ val)\{}
\DoxyCodeLine{00050\ \ \ \ \ nodes[u]\ =\ val;}
\DoxyCodeLine{00051\ \ \ \}}
\DoxyCodeLine{00052\ }
\DoxyCodeLine{00053\ }
\DoxyCodeLine{00061\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classbest__first_a500d360531f7f47a8cc5962d47dc41c4}{has\_edge}}(T\ u,\ T\ v)\{}
\DoxyCodeLine{00062\ \ \ \ \ \textcolor{keywordflow}{if}(adj.find(u)\ !=\ adj.end())\{}
\DoxyCodeLine{00063\ \ \ \ \ \ \ \textcolor{keywordflow}{for}(std::pair<T,\ double>\ \&x\ :\ adj[u])\{}
\DoxyCodeLine{00064\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(x.first\ ==\ v)\{}
\DoxyCodeLine{00065\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00066\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00067\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00068\ \ \ \ \ \}}
\DoxyCodeLine{00069\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00070\ \ \ \}}
\DoxyCodeLine{00071\ \ }
\DoxyCodeLine{00077\ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classbest__first_a0184eaa1f2eb8fa65a7e7f8bafc30dea}{add\_edge}}(T\ u,\ T\ v)\{}
\DoxyCodeLine{00078\ \ \ \ \ \textcolor{keywordflow}{try}\{}
\DoxyCodeLine{00079\ \ \ \ \ \ \ \textcolor{keywordflow}{if}(nodes.find(u)\ !=\ nodes.end()\ \&\&\ nodes.find(v)\ !=\ nodes.end())\{}
\DoxyCodeLine{00080\ \ \ \ \ \ \ \ \ adj[u].push\_back(std::make\_pair(v,\ nodes[v]));}
\DoxyCodeLine{00081\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00082\ \ \ \ \ \ \ \textcolor{keywordflow}{else}\{}
\DoxyCodeLine{00083\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{throw}\ std::logic\_error(\textcolor{stringliteral}{"{}One\ of\ the\ two\ nodes\ that\ passed\ to\ the\ function\ do\ not\ exist\ in\ the\ graph"{}});}
\DoxyCodeLine{00084\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00085\ \ \ \ \ \}}
\DoxyCodeLine{00086\ \ \ \ \ \textcolor{keywordflow}{catch}(std::logic\_error\ \&e)\{}
\DoxyCodeLine{00087\ \ \ \ \ \ \ std::cerr\ <<\ e.what()\ <<\ \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{00088\ \ \ \ \ \}}
\DoxyCodeLine{00089\ \ \ \}}
\DoxyCodeLine{00090\ \ \ }
\DoxyCodeLine{00098\ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classbest__first_ad26f8ac0e1c3b07108054faa049a1c58}{search}}(T\ start,\ T\ end)\{}
\DoxyCodeLine{00099\ \ \ \ \ \textcolor{keywordflow}{if}(adj.empty())\{}
\DoxyCodeLine{00100\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00101\ \ \ \ \ \}}
\DoxyCodeLine{00102\ \ \ \ \ std::unordered\_map<T,\ bool>\ visited;}
\DoxyCodeLine{00103\ \ \ \ \ std::priority\_queue<std::pair<T,\ double>,\ std::vector<std::pair<T,\ double>\ >,\ std::greater<std::pair<T,\ double>\ >\ >\ q;}
\DoxyCodeLine{00104\ \ \ \ \ q.push(\{start,\ nodes[start]\});}
\DoxyCodeLine{00105\ \ \ \ \ visited[start]\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{00106\ \ \ \ \ \textcolor{keywordflow}{while}(!q.empty())\{}
\DoxyCodeLine{00107\ \ \ \ \ \ \ int64\_t\ size\ =\ q.size();}
\DoxyCodeLine{00108\ \ \ \ \ \ \ \textcolor{keywordflow}{for}(int64\_t\ i\ =\ 0;\ i<size;\ i++)\{}
\DoxyCodeLine{00109\ \ \ \ \ \ \ \ \ std::pair<T,\ double>\ current\ =\ q.top();}
\DoxyCodeLine{00110\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(current.first\ ==\ end)\{}
\DoxyCodeLine{00111\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00112\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00113\ \ \ \ \ \ \ \ \ q.pop();}
\DoxyCodeLine{00114\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}(std::pair<T,\ double>\ \&x:\ adj[current.first])\{}
\DoxyCodeLine{00115\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(visited.find(x.first)\ ==\ visited.end()\ \&\&\ x.second\ <=\ nodes[current.first])\{}
\DoxyCodeLine{00116\ \ \ \ \ \ \ \ \ \ \ \ \ visited[x.first]\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{00117\ \ \ \ \ \ \ \ \ \ \ \ \ q.push(\{x.first,\ nodes[x.first]\});}
\DoxyCodeLine{00118\ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00119\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00120\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00121\ \ \ \ \ \}}
\DoxyCodeLine{00122\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00123\ \ \ \}}
\DoxyCodeLine{00124\ \};}
\DoxyCodeLine{00125\ }
\DoxyCodeLine{00126\ }
\DoxyCodeLine{00127\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00128\ }

\end{DoxyCode}
